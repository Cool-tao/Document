###### 方法区（Method Area）

方法区与Java 堆一样，是各个线程共享的内存区域，
它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。

Java 虚拟机规范对这个区域的限制非常宽松，除了和Java 堆一样不需要连续的内存，
可以选择固定大小或者可扩展外，还可以选择不实现垃圾收集。
相对而言，垃圾收集行为在这个区域是比较少出现的，但并非数据进入了方法区就如永久代的名字
一样“永久”存在了。这个区域的内存回收目标主要是针对常量池的回收和对类型的卸载，
一般来说这个区域的回收“成绩”难以令人满意，尤其是类型的卸载，条件相当苛刻，
但是这部分区域的回收确实是有必要的。根据Java 虚拟机规范的规定，
当方法区无法满足内存分配需求时，将抛出OutOfMemoryError 异常。


- 运行时常量池（Runtime Constant Pool）

运行时常量池是方法区的一部分。 Class文件中除了有类的版本、 字段、 方法、 接口等描述信息外，
还有一项信息是常量池，用于存放编译期生成的各种字面量和符号引用，
这部分内容将在类加载后进入方法区的运行时常量池中存放。
Java虚拟机对Class文件每一部分（自然也包括常量池）的格式都有严格规定，
每一个字节用于存储哪种数据都必须符合规范上的要求才会被虚拟机认可、 装载和执行，
但对于运行时常量池，Java虚拟机规范没有做任何细节的要求，不同的提供商实现的虚拟机，
可以按照自己的需要来实现这个内存区域。 不过，一般来说，除了保存Class文件中描述的符号引用外，
还会把翻译出来的直接引用也存储在运行时常量池中。
运行时常量池相对于Class文件常量池的另外一个重要特征是具备动态性，
Java语言并不要求常量一定只有编译期才能产生，也就是并非预置入Class文件中常量池的内容，
才能进入方法区运行时常量池，运行期间也可能将新的常量放入池中，
这种特性被开发人员利用得比较多的便是String类的intern（）方法。
既然运行时常量池是方法区的一部分，自然受到方法区内存的限制，
当常量池无法再申请到内存时会抛出OutOfMemoryError异常。

